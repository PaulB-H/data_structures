<!DOCTYPE html>
<html lang="en" style="height: 100%">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Data Structures in Javascript</title>
    <!-- Highlight.js default CSS -->
    <!-- <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/default.min.css"
    /> -->
    <!-- Highlight.js vs2015 CSS -->
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/styles/vs2015.min.css"
      integrity="sha512-w8aclkBlN3Ha08SMwFKXFJqhSUx2qlvTBFLLelF8sm4xQnlg64qmGB/A6pBIKy0W8Bo51yDMDtQiPLNRq1WMcQ=="
      crossorigin="anonymous"
    />
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        scrollbar-width: thin;
        scrollbar-color: black white;
        -webkit-scrollbar-thumb: black;
      }
      #content {
        padding: 5px;
        max-width: 600px;
        margin: 0 auto;
      }

      hr {
        margin: 5px 0 5px 0;
      }
      pre {
        white-space: break-spaces;
        margin: 10px 0;
      }
      h2 {
        margin-bottom: 3px;
      }

      #page-header {
      }
      #header-title {
        text-decoration: underline;
      }
      .header-link {
      }
      .header-link p {
        margin: 5px 0;
      }
      #page-header ul li {
        margin-left: 25px;
      }
      #unfinished a {
        color: black;
        text-decoration: none;
      }

      .item {
      }
      .item hr {
        display: none;
      }

      .item-header {
        text-align: center;
        max-width: max-content;
        margin: 0 auto;
      }
      .item-title {
      }
      .item-resource-link {
        display: none;
      }

      .item-desc {
      }
      .item-desc-text {
        text-indent: 25px;
        margin-top: 5px;
      }
      .item-desc pre {
      }

      .item-code-example {
      }

      /* highlight.js line numbers */
      /* 10px pad to the right of all line numbers */
      tr td {
        padding-right: 10px !important;
        vertical-align: baseline;
      }
    </style>
  </head>
  <body style="height: 100%">
    <div id="content">
      <div id="page-header">
        <h2 id="header-title">Data Structures</h2>

        <a
          class="header-link"
          href="https://www.youtube.com/watch?v=t2CEgPsws3U"
          target="_blank"
        >
          <p>Free Code Camp - Data Structures</p>
        </a>
        <a
          class="header-link"
          href="https://www.freecodecamp.org"
          target="_blank"
        >
          <p>Free Code Camp</p>
        </a>
        <a class="header-link" href="https://www.devbypaul.ca" target="_blank">
          <p>devbypaul</p>
        </a>
        <h3>Structures Covered</h3>
        <ul>
          <li><a href="#stack">Stack</a></li>
          <li><a href="#set">Sets</a></li>
          <li><a href="#queue">Queue</a></li>
          <li><a href="#priority-queue">Priority Queue</a></li>
          <li><a href="#binary-search-tree">Binary Search Tree</a></li>
          <div id="unfinished">
            <li>
              <a href="#bst-traversal-height"
                >Binary Search Tree: Traversal & Height</a
              >
            </li>
            <li><a href="#hash-tables">Hash Tables</a></li>
            <li><a href="#linked-list">Linked List</a></li>
            <li><a href="#trie">Trie</a></li>
            <li><a href="#heap">Heap</a></li>
            <li>
              <a href="#stack"></a>Graphs: adjacency list, adjacency matrix,
              incidence matrix
            </li>
            <li><a href="#stack"></a>Graphs: breadth-first search</li>
          </div>
        </ul>
        <br />
      </div>
      <hr />
      <!-- END page header -->

      <div class="item" id="stack">
        <div class="item-header">
          <h2 class="item-title">Stack</h2>
          <a class="item-resource-link" href="enter_link_here" target="_blank">
            <p>Link to resource</p>
          </a>
        </div>

        <hr />

        <div class="item-desc">
          <h3>Structure Description</h3>
          <p class="item-desc-text">
            A stack is a last-in-first-out type of structure. Very much like a
            stack of books. Example: browser back button.
          </p>
          <pre>
Usual functions: 
  push, pop, peek, length</pre
          >
          <p class="item-desc-text">
            Arrays in Javascript already have all the functions (and more) to
            use as a stack, so you could just use an array as a stack. We can
            also create a stack class with ONLY the functionality we would
            expect from a stack.
          </p>
          <br />
        </div>

        <hr />

        <div class="item-code-example">
          <h3>Palindrome Check with Stack (as an array)</h3>
          <pre>
            <code class="language-javascript">let letters = []; // this is our stack

let word = "racecar"

let rword = "";

// put letters of word into stack
for (let i = 0; i < word.length; i++ ) {
  letters.push(word[i])
}

// pop off the stack in reverse order
for (let i = 0; i < word.length; i++ ) {
  rword += letters.pop();
}

if (rword === word) {
  console.log(word + " is a palindrome.");
} else {
  console.log(word + " is not a palindrome.");
}
            </code>
          </pre>
          <h3>Creating a custom stack function</h3>
          <pre>
            <code class="language-javascript">let stack = function () {
  this.count = 0;
  this.storage = {};

  // add value to end of stack
  this.push = function (value) {
    this.storage[this.count] = value;
    this.count++;
  }

  this.pop = function () {
    if (this.count === 0) {
      return undefined;
    }

    this.count --;
    let result = this.storage[this.count];
    delete this.storage[this.count];
    return result
  }

  this.size = function () {
    return this.count();
  }

  this.peek = function () {
    return this.storage[this.count-1];
  }

}

let myStack = new stack();
            </code>
          </pre>
        </div>
      </div>
      <hr />
      <!-- END stack -->

      <div class="item" id="set">
        <div class="item-header">
          <h2 class="item-title">Set</h2>
          <a class="item-resource-link" href="enter_link_here" target="_blank">
            <p>Link to resource</p>
          </a>
        </div>

        <hr />

        <div class="item-desc">
          <h3>Structure Description</h3>
          <p class="item-desc-text">
            Sets are like an array, but with no duplicates, and no particular
            order. They are useful to check just for the presence of an item.
            ES6 has a built in set class, however it does not contain all the
            methods common to sets.
          </p>
          <pre>
Usual methods:
  has, values, add, remove, size, union, intersection, difference, subset

Build in ES6 set ONLY has :
  values, add, remove(as delete), and size(size as a property not method)

- Note: In subset() the every() method we use tests if all items in the array pass a test implemented by the provided function, in our case we pass in otherSet.has()
          </pre>
        </div>

        <hr />

        <div class="item-code-example">
          <h3>Example in Javascript:</h3>
          <pre>
            <code class="language-javascript">function mySet() {
  // This will hold the set. Normally arrays can have duplicate items, but we will prevent that in our add() method
  let collection = [];

  // Check for presence of element, returns true or false
  // Note: indexOf will return -1 if it does not exist, so if it is NOT -1 it DOES exist
  this.has = function (element) {
    return collection.indexOf(element) !== -1;
  };

  // return all values in set
  this.values = function () {
    return collection;
  };

  // add element to set
  this.add = function (element) {
    if (!this.has(element)) {
      collection.push(element);
      return true;
    }
    return false;
  };

  // remove from set
  this.remove = function (element) {
    if (this.has(element)) {
      index = collection.indexOf(element);
      collection.splice(index, 1);
      return true;
    }
    return false;
  };

  // returns size of collection
  this.size = function () {
    return collection.length;
  };

  // return union of two sets
  this.union = function (otherSet) {
    let unionSet = new mySet();
    let firstSet = this.values();
    let secondSet = otherSet.values();
    firstSet.forEach(function (e) {
      unionSet.add(e);
    });
    secondSet.forEach(function (e) {
      unionSet.add(e);
    });
    return unionSet;
  };

  // return intersection of two sets as a new set
  // (all of the items that are in both sets)
  this.intersection = function (otherSet) {
    let intersectionSet = new mySet();
    let firstSet = this.values();
    firstSet.forEach(function (e) {
      if (otherSet.has(e)) {
        intersectionSet.add(e);
      }
    });
    return intersectionSet;
  };

  // return difference between two sets as a new set
  this.difference = function (otherSet) {
    let differenceSet = new mySet();
    let firstSet = this.values();
    firstSet.forEach(function (e) {
      if (!otherSet.has(e)) {
        differenceSet.add(e);
      }
    });
    return differenceSet;
  };

  // Check if set is a subset of a different set
  // subset: If the first set is completely contained within a different set
  this.subset = function (otherSet) {
    let firstSet = this.values();
    return firstSet.every(function (value) {
      return otherSet.has(value);
    });
  };
}

let setA = new mySet();
let setB = new mySet();

setA.add("a")
setB.add("b")
setB.add("c")
setB.add("a")
setB.add("a")

console.log(setA.subset(setB))
console.log(setA.intersection(setB).values())
console.log(setB.difference(setA).values())

// Examples using ES6 Set

let setC = new Set();
let setD = new Set();

setC.add("a")
setD.add("b")
setD.add("c")
setD.add("a")
setD.add("a")

console.log(setD.values())
setD.delete("a")
console.log(setD.has("a"))
console.log(setD.add("a"))
            </code>
          </pre>
        </div>
      </div>
      <hr />
      <!-- END set -->

      <div class="item" id="queue">
        <div class="item-header">
          <h2 class="item-title">Queue</h2>
          <a class="item-resource-link" href="enter_link_here" target="_blank">
            <p>Link to resource</p>
          </a>
        </div>

        <hr />

        <div class="item-desc">
          <h3>Structure Description</h3>
          <p class="item-desc-text">
            The que is a first-in-first-out data structure. You can use a
            JavaScript array as a queue, but if you want to limit it to the
            methods a queue normally has, we will have to build the class
            ourselves.
          </p>
          <pre>
Usual methods:
  print, enqueue, dequeue, front, size, isEmpty
          </pre>
        </div>

        <hr />

        <div class="item-code-example">
          <h3>Example in Javascript:</h3>
          <pre>
            <code class="language-javascript">function Queue () {
  let collection = []

  // helper function to print queue
  this.print = function () {
    console.log(collection)
  };

  // add item to que at end of array
  this.enqueue = function (element) {
    collection.push(element)
  };

  // take off first item from array
  this.dequeue = function () {
    return collection.shift()
  };

  // returns front item without removing it
  this.front = function () {
    return collection[0]
  };

  this.size = function () {
    return collection.length;
  };

  // if empty returns true, else returns false
  this.isEmpty = function () {
    return (collection.length === 0)
  };

}

let q = new Queue();

q.enqueue("a");
q.enqueue("b");
q.enqueue("c");
q.print();
q.dequeue();
console.log(q.front());
q.print();
            </code>
          </pre>
        </div>
      </div>
      <hr />
      <!-- END queue -->

      <div class="item" id="priority-queue">
        <div class="item-header">
          <h2 class="item-title">Priority Queue</h2>
          <a class="item-resource-link" href="enter_link_here" target="_blank">
            <p>Link to resource</p>
          </a>
        </div>

        <hr />

        <div class="item-desc">
          <h3>Structure Description</h3>
          <p class="item-desc-text">
            In a priority queue not only do you pass the element into the queue,
            you also pass the priority of the element. If all the priorities are
            the same number, it will behave like a normal queue, but if you pass
            in elements with different priorities, the elements with higher
            priority will get sent to the front of the queue depending on
            priority level.
          </p>
          <p class="item-desc-text">
            Everything is the same in a priority que, except the enque function,
            if the queue is NOT empty, we have to check each item in the queue
            to check what the priorities are vs the item we are adding priority
          </p>
          <p class="item-desc-text">
            Note: for our priority check, the enqueue() method is the priority
            of the element we are passing into the que LESS than the priority of
            the item in the collection we are checking. Checking starts from
            front to back
          </p>
          <pre>
Usual methods same as normal queue:
  print, enqueue, dequeue, front, size, isEmpty

Important: When passing in items to enqueue pass item then priority level
  let myPriorityQueue = new PriorityQueue();
  
  myPriorityQueue.enqueue("Watch netflix", 0)
  myPriorityQueue.enqueue("Study", 5)
  myPriorityQueue.enqueue("exercise", 3)

  myPriorityQueue.printCollection();
  // Returns [["Study", 5], ["Exercise", 3], ["Watch netflix", 0]]
          </pre>
        </div>

        <hr />

        <div class="item-code-example">
          <h3>Example in Javascript:</h3>
          <pre>
            <code class="language-javascript">function PriorityQueue () {
  let collection = [];

  this.printCollection = function () {
    (console.log(collection));
  };

  // this method is where priority check is done
  this.enqueue = function (element) {
    if (this.isEmpty()) {
      collection.push(element);
    } else {
      let added = false;
      for (let i = 0; i < collection.length; i++) {
        if (element[1] < collection[i][1]) {
          collection.splice(i, 0, element);
          added = true;
          break;
        }
      }
      if (!added) {
        collection.push(element);
      }
    }
  }

  // For dequeue() we could return the entire element with item and priority, here we are just returning the item itself
  this.dequeue = function () {
    let value = collection.shift();
    return value[0];
  };

  this.front = function () {
    return collection[0];
  };
  this.size = function () {
    return collection.length;
  };
  this.isEmpty = function () {
    return collection.length === 0;
  };
};
            </code>
          </pre>
        </div>
      </div>
      <hr />
      <!-- END priority queue -->

      <div class="item" id="binary-search-tree">
        <div class="item-header">
          <h2 class="item-title">Binary Search Tree</h2>
          <a class="item-resource-link" href="enter_link_here" target="_blank">
            <p>Link to resource</p>
          </a>
        </div>

        <hr />

        <div class="item-desc">
          <h3>Structure Description</h3>
          <p class="item-desc-text">
            Tree data structure is a way to store data where, when visualised,
            looks like a tree we see in nature. All data points in the tree are
            called nodes. The top node is called the ROOT node. From there it
            branches out into additional nodes, each of which might have more
            child nodes of their own and so on.
          </p>
          <p class="item-desc-text">
            Nodes with branches leading to other nodes are referred to as the
            parent of those nodes, those children can also be the parent node to
            their own branches. Leaf nodes are at the end of the tree with no
            children.
          </p>
          <p class="item-desc-text">
            While the tree data structure can have any number of branches at a
            single node, a binary tree can only have two branches from each
            node.
          </p>
          <p class="item-desc-text">
            Binary trees are also ordered, each left subtree is less than or
            equal to the parent node, and each right subtree is greater than or
            equal to the parent node.
          </p>
          <p class="item-desc-text">
            Because they use the principle of binary search, on average
            operations can skip half the tree. Each lookup, insertion, or
            deletion takes time proportional to the logarithm of the number of
            items stored in the tree.
          </p>
          <p class="item-desc-text">
            This is better than the linear time required to find items by key in
            an unsorted array, but slower than the corresponding operations on a
            hash table.
          </p>
          <pre>
Usual methods
  add, findMin, findMax, find, isPresent, remove
          </pre>
        </div>

        <!-- Time complexity in big O notation
        ---------------------------------
          Algorithm   Average   Worst case
          Space       O(n)      O(n)
          Search      O(log n)  O(n)
          Insert      O(log n)  O(n)
          Delete      O(log n)  O(n) -->

        <hr />

        <div class="item-code-example">
          <h3>Example in Javascript:</h3>
          <pre>
            <code class="language-javascript">// We are using classes here instead of functions as done with previous structures

// Node class is each node in the tree
// Has pointers to whatever is left / right of it
class Node {
  constructor(data, left = null, right = null) {
    this.data = data;
    this.left = left;
    this.right = right;
  }
}

class BST {
  // constructor creates root node which starts as null
  constructor() {
    this.root = null;
  }
  add(data) {
    const node = this.root;
    if (node === null) {
      this.root = new Node(data);
      return;
    } else {
      const searchTree = function (node) {
        if (data < node.data) {
          if (node.left === null) {
            node.left = new Node(data);
            return;
          } else if (node.left !== null) {
            return searchTree(node.left);
          }
        } else if (data > node.data) {
          if (node.right === null) {
            node.right = new Node(data);
            return;
          } else if (node.right !== null) {
            return searchTree(node.right);
          }
        } else {
          return null;
        }
      };
      return searchTree(node);
    }
  }
  // minimum value will be most left node
  findMin() {
    let current = this.root;
    while (current.left !== null) {
      current = current.left;
    }
    return current.data;
  }
  // max node will be most right node
  findMax() {
    let current = this.root;
    while (current.right !== null) {}
  }
  find(data) {
    let current = this.root;
    while (current.data !== data) {
      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right;
      }
      if (current === null) {
        return null;
      }
    }
    return current;
  }
  // Similar to find but just returns true or false if item exist or not
  isPresent(data) {
    let current = this.root;
    while (current) {
      if (data === current.data) {
        return true;
      }
      if (data < current.data) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    return false;
  }
  // There is going to be a recursive function to remove
  remove(data) {
    const removeNode = function (node, data) {
      if (node == null) {
        return null;
      }
      if (data == node.data) {
        // node has no children
        if (node.left == null && node.right == null) {
          return null;
        }
        // node has no left child
        if (node.left == null) {
          return node.right;
        }
        // node has no right child
        if (node.right == null) {
          return node.left;
        }
        // node has 2 children
        let tempNode = node.right;
        while (tempNode.left !== null) {
          tempNode = tempNode.left;
        }
        node.data = tempNode.data;
        node.right = removeNode(node.right, tempNode.data);
        return node;
      } else if (data < node.data) {
        node.left = removeNode(node.left, data);
        return node;
      } else {
        node.right = removeNode(node.right, data);
        return node;
      }
    };
    // this is where the removeNode() function is actually called
    this.root = removeNode(this.root, data);
  }
  isBalanced () {
    return (this.findMinHeight () >= this.findMaxHeight() -1)
  }
  findMinHeight (node = this.root) {
    if( node == null) {
      return -1
    };
    let left = this.findMinHeight(node.left);
    let right = this.findMinHeight(node.right);
    if(left < right) {
      return left + 1;
    } else {
      return right + 1;
    };
  }
  findMaxHeight (node = this.root) {
    if (node == null) {
      return -1;
    }
    let left = this.findMaxHeight(node.left)
    let right = this.findMaxHeight(node.right)
    if (left > right) {
      return left + 1;
    } else {
      return right + 1;
    };
  }
}
            </code>
          </pre>
        </div>
      </div>
      <hr />
      <!-- END binary search tree -->

      <div class="item" id="structure-name" style="display: none">
        <div class="item-header">
          <h2 class="item-title">Structure Name</h2>
          <a class="item-resource-link" href="enter_link_here" target="_blank">
            <p>Link to resource</p>
          </a>
        </div>

        <hr />

        <div class="item-desc">
          <h3>Structure Description</h3>
          <p class="item-desc-text">
            25px text indented text block here Lorem ipsum dolor sit amet,
            consectetur adipiscing elit. Suspendisse vitae leo ex. Etiam nec
            lectus eu ex tempus sagittis eu quis elit.
          </p>
          <p class="item-desc-text">
            25px text indented text block here Fusce sed venenatis diam. In
            molestie est vitae augue pretium consequat. Praesent suscipit mauris
            et dignissim elementum. Morbi sed ante tristique, pulvinar augue
            sed, cursus felis. Nulla facilisi. Donec non arcu id diam molestie
            accumsan.
          </p>
          <pre>
Plaintext pre formatting 
  No highlighting here
          </pre>
        </div>

        <hr />

        <div class="item-code-example">
          <h3>Example in Javascript:</h3>
          <pre>
            <code class="language-javascript">function JsCodeHere(){
  let string = "
    Notice how the first line is inline with the
    opening code tag - This is necessary for proper
    highlight.js line numbers
  ";

  let string = "
    Also beucase of css 'tr td {padding-right: 10px}'
    no longer need to add extra space to left of
    code to distance from line numbers
  ";
  
  return solution;
}
            </code>
          </pre>
        </div>
      </div>
      <hr />
      <!-- END template -->
    </div>
    <!-- END content -->

    <!-- Highlight.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.5.0/highlight.min.js"></script>
    <!-- Highlight.js Line Numbers -->
    <script src="https://cdn.jsdelivr.net/npm/highlightjs-line-numbers.js@2.6.0/dist/highlightjs-line-numbers.min.js"></script>
    <script>
      hljs.initHighlightingOnLoad();
      hljs.initLineNumbersOnLoad();
    </script>
  </body>
</html>
